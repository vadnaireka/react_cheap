{"ast":null,"code":"'use strict';\n\nvar _DOMMouseMoveTracker = require('./DOMMouseMoveTracker');\n\nvar _DOMMouseMoveTracker2 = _interopRequireDefault(_DOMMouseMoveTracker);\n\nvar _Keys = require('./Keys');\n\nvar _Keys2 = _interopRequireDefault(_Keys);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _createReactClass = require('create-react-class');\n\nvar _createReactClass2 = _interopRequireDefault(_createReactClass);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _ReactDOM = require('./ReactDOM');\n\nvar _ReactDOM2 = _interopRequireDefault(_ReactDOM);\n\nvar _ReactComponentWithPureRenderMixin = require('./ReactComponentWithPureRenderMixin');\n\nvar _ReactComponentWithPureRenderMixin2 = _interopRequireDefault(_ReactComponentWithPureRenderMixin);\n\nvar _ReactWheelHandler = require('./ReactWheelHandler');\n\nvar _ReactWheelHandler2 = _interopRequireDefault(_ReactWheelHandler);\n\nvar _cssVar = require('./cssVar');\n\nvar _cssVar2 = _interopRequireDefault(_cssVar);\n\nvar _cx = require('./cx');\n\nvar _cx2 = _interopRequireDefault(_cx);\n\nvar _emptyFunction = require('./emptyFunction');\n\nvar _emptyFunction2 = _interopRequireDefault(_emptyFunction);\n\nvar _FixedDataTableTranslateDOMPosition = require('./FixedDataTableTranslateDOMPosition');\n\nvar _FixedDataTableTranslateDOMPosition2 = _interopRequireDefault(_FixedDataTableTranslateDOMPosition);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Scrollbar\n * @typechecks\n */\n\n\nvar UNSCROLLABLE_STATE = {\n  position: 0,\n  scrollable: false\n};\nvar FACE_MARGIN = parseInt((0, _cssVar2.default)('scrollbar-face-margin'), 10);\nvar FACE_MARGIN_2 = FACE_MARGIN * 2;\nvar FACE_SIZE_MIN = 30;\nvar KEYBOARD_SCROLL_AMOUNT = 40;\nvar _lastScrolledScrollbar = null;\n\nvar getTouchX = function getTouchX(e) {\n  return Math.round(e.targetTouches[0].pageX - e.target.getBoundingClientRect().x);\n};\n\nvar getTouchY = function getTouchY(e) {\n  return Math.round(e.targetTouches[0].pageY - e.target.getBoundingClientRect().y);\n};\n\nvar Scrollbar = (0, _createReactClass2.default)({\n  displayName: 'Scrollbar',\n  mixins: [_ReactComponentWithPureRenderMixin2.default],\n  propTypes: {\n    contentSize: _propTypes2.default.number.isRequired,\n    defaultPosition: _propTypes2.default.number,\n    isOpaque: _propTypes2.default.bool,\n    orientation: _propTypes2.default.oneOf(['vertical', 'horizontal']),\n    onScroll: _propTypes2.default.func,\n    position: _propTypes2.default.number,\n    size: _propTypes2.default.number.isRequired,\n    trackColor: _propTypes2.default.oneOf(['gray']),\n    zIndex: _propTypes2.default.number,\n    verticalTop: _propTypes2.default.number\n  },\n  getInitialState: function getInitialState()\n  /*object*/\n  {\n    var props = this.props;\n    return this._calculateState(props.position || props.defaultPosition || 0, props.size, props.contentSize, props.orientation);\n  },\n  componentWillReceiveProps: function componentWillReceiveProps(\n  /*object*/\n  nextProps) {\n    var controlledPosition = nextProps.position;\n\n    if (controlledPosition === undefined) {\n      this._setNextState(this._calculateState(this.state.position, nextProps.size, nextProps.contentSize, nextProps.orientation));\n    } else {\n      this._setNextState(this._calculateState(controlledPosition, nextProps.size, nextProps.contentSize, nextProps.orientation), nextProps);\n    }\n  },\n  getDefaultProps: function getDefaultProps()\n  /*object*/\n  {\n    return {\n      defaultPosition: 0,\n      isOpaque: false,\n      onScroll: _emptyFunction2.default,\n      orientation: 'vertical',\n      zIndex: 99\n    };\n  },\n  faceRef: function faceRef(ref) {\n    this.face = ref;\n  },\n  rootRef: function rootRef(ref) {\n    this.root = ref;\n  },\n  render: function render()\n  /*?object*/\n  {\n    if (!this.state.scrollable) {\n      return null;\n    }\n\n    var size = this.props.size;\n    var mainStyle;\n    var faceStyle;\n    var isHorizontal = this.state.isHorizontal;\n    var isVertical = !isHorizontal;\n    var isActive = this.state.focused || this.state.isDragging;\n    var faceSize = this.state.faceSize;\n    var isOpaque = this.props.isOpaque;\n    var verticalTop = this.props.verticalTop || 0;\n    var mainClassName = (0, _cx2.default)({\n      'ScrollbarLayout/main': true,\n      'ScrollbarLayout/mainVertical': isVertical,\n      'ScrollbarLayout/mainHorizontal': isHorizontal,\n      'public/Scrollbar/main': true,\n      'public/Scrollbar/mainOpaque': isOpaque,\n      'public/Scrollbar/mainActive': isActive\n    });\n    var faceClassName = (0, _cx2.default)({\n      'ScrollbarLayout/face': true,\n      'ScrollbarLayout/faceHorizontal': isHorizontal,\n      'ScrollbarLayout/faceVertical': isVertical,\n      'public/Scrollbar/faceActive': isActive,\n      'public/Scrollbar/face': true\n    });\n    var position = this.state.position * this.state.scale + FACE_MARGIN;\n\n    if (isHorizontal) {\n      mainStyle = {\n        width: size\n      };\n      faceStyle = {\n        width: faceSize - FACE_MARGIN_2\n      };\n      (0, _FixedDataTableTranslateDOMPosition2.default)(faceStyle, position, 0, this._initialRender);\n    } else {\n      mainStyle = {\n        top: verticalTop,\n        height: size\n      };\n      faceStyle = {\n        height: faceSize - FACE_MARGIN_2\n      };\n      (0, _FixedDataTableTranslateDOMPosition2.default)(faceStyle, 0, position, this._initialRender);\n    }\n\n    mainStyle.touchAction = 'none';\n    mainStyle.zIndex = this.props.zIndex;\n\n    if (this.props.trackColor === 'gray') {\n      mainStyle.backgroundColor = (0, _cssVar2.default)('fbui-desktop-background-light');\n    }\n\n    return _react2.default.createElement('div', {\n      onFocus: this._onFocus,\n      onBlur: this._onBlur,\n      onKeyDown: this._onKeyDown,\n      onMouseDown: this._onMouseDown,\n      onTouchCancel: this._onTouchCancel,\n      onTouchEnd: this._onTouchEnd,\n      onTouchMove: this._onTouchMove,\n      onTouchStart: this._onTouchStart,\n      className: mainClassName,\n      ref: this.rootRef,\n      style: mainStyle\n    }, _react2.default.createElement('div', {\n      ref: this.faceRef,\n      className: faceClassName,\n      style: faceStyle\n    }));\n  },\n  componentWillMount: function componentWillMount() {\n    var isHorizontal = this.props.orientation === 'horizontal';\n    var onWheel = isHorizontal ? this._onWheelX : this._onWheelY;\n    this._wheelHandler = new _ReactWheelHandler2.default(onWheel, this._shouldHandleX, // Should hanlde horizontal scroll\n    this._shouldHandleY // Should handle vertical scroll\n    );\n    this._initialRender = true;\n  },\n  componentDidMount: function componentDidMount() {\n    this.root && this.root.addEventListener('wheel', this._wheelHandler.onWheel, {\n      passive: false\n    });\n    this._mouseMoveTracker = new _DOMMouseMoveTracker2.default(this._onMouseMove, this._onMouseMoveEnd, document.documentElement, this.props.touchEnabled);\n\n    if (this.props.position !== undefined && this.state.position !== this.props.position) {\n      this._didScroll();\n    }\n\n    this._initialRender = false;\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    this.root && this.root.removeEventListener('wheel', this._wheelHandler.onWheel, {\n      passive: false\n    });\n    this._nextState = null;\n\n    this._mouseMoveTracker.releaseMouseMoves();\n\n    if (_lastScrolledScrollbar === this) {\n      _lastScrolledScrollbar = null;\n    }\n\n    delete this._mouseMoveTracker;\n  },\n  scrollBy: function scrollBy(\n  /*number*/\n  delta) {\n    this._onWheel(delta);\n  },\n  _shouldHandleX: function _shouldHandleX(\n  /*number*/\n  delta)\n  /*boolean*/\n  {\n    return this.props.orientation === 'horizontal' ? this._shouldHandleChange(delta) : false;\n  },\n  _shouldHandleY: function _shouldHandleY(\n  /*number*/\n  delta)\n  /*boolean*/\n  {\n    return this.props.orientation !== 'horizontal' ? this._shouldHandleChange(delta) : false;\n  },\n  _shouldHandleChange: function _shouldHandleChange(\n  /*number*/\n  delta)\n  /*boolean*/\n  {\n    var nextState = this._calculateState(this.state.position + delta, this.props.size, this.props.contentSize, this.props.orientation);\n\n    return nextState.position !== this.state.position;\n  },\n  _calculateState: function _calculateState(\n  /*number*/\n  position,\n  /*number*/\n  size,\n  /*number*/\n  contentSize,\n  /*string*/\n  orientation)\n  /*object*/\n  {\n    if (size < 1 || contentSize <= size) {\n      return UNSCROLLABLE_STATE;\n    }\n\n    var stateKey = position + '_' + size + '_' + contentSize + '_' + orientation;\n\n    if (this._stateKey === stateKey) {\n      return this._stateForKey;\n    } // There are two types of positions here.\n    // 1) Phisical position: changed by mouse / keyboard\n    // 2) Logical position: changed by props.\n    // The logical position will be kept as as internal state and the `render()`\n    // function will translate it into physical position to render.\n\n\n    var isHorizontal = orientation === 'horizontal';\n    var scale = size / contentSize;\n    var faceSize = size * scale;\n\n    if (faceSize < FACE_SIZE_MIN) {\n      scale = (size - FACE_SIZE_MIN) / (contentSize - size);\n      faceSize = FACE_SIZE_MIN;\n    }\n\n    var scrollable = true;\n    var maxPosition = contentSize - size;\n\n    if (position < 0) {\n      position = 0;\n    } else if (position > maxPosition) {\n      position = maxPosition;\n    }\n\n    var isDragging = this._mouseMoveTracker ? this._mouseMoveTracker.isDragging() : false; // This function should only return flat values that can be compared quiclky\n    // by `ReactComponentWithPureRenderMixin`.\n\n    var state = {\n      faceSize: faceSize,\n      isDragging: isDragging,\n      isHorizontal: isHorizontal,\n      position: position,\n      scale: scale,\n      scrollable: scrollable\n    }; // cache the state for later use.\n\n    this._stateKey = stateKey;\n    this._stateForKey = state;\n    return state;\n  },\n  _onWheelY: function _onWheelY(\n  /*number*/\n  deltaX,\n  /*number*/\n  deltaY) {\n    this._onWheel(deltaY);\n  },\n  _onWheelX: function _onWheelX(\n  /*number*/\n  deltaX,\n  /*number*/\n  deltaY) {\n    this._onWheel(deltaX);\n  },\n  _onWheel: function _onWheel(\n  /*number*/\n  delta) {\n    var props = this.props; // The mouse may move faster then the animation frame does.\n    // Use `requestAnimationFrame` to avoid over-updating.\n\n    this._setNextState(this._calculateState(this.state.position + delta, props.size, props.contentSize, props.orientation));\n  },\n  _onMouseDown: function _onMouseDown(\n  /*object*/\n  event) {\n    var nextState;\n\n    if (event.target !== _ReactDOM2.default.findDOMNode(this.face)) {\n      // Both `offsetX` and `layerX` are non-standard DOM property but they are\n      // magically available for browsers somehow.\n      var nativeEvent = event.nativeEvent;\n      var position = this.state.isHorizontal ? nativeEvent.offsetX || nativeEvent.layerX || getTouchX(nativeEvent) : nativeEvent.offsetY || nativeEvent.layerY || getTouchY(nativeEvent); // MouseDown on the scroll-track directly, move the center of the\n      // scroll-face to the mouse position.\n\n      var props = this.props;\n      position /= this.state.scale;\n      nextState = this._calculateState(position - this.state.faceSize * 0.5 / this.state.scale, props.size, props.contentSize, props.orientation);\n    } else {\n      nextState = {};\n    }\n\n    nextState.focused = true;\n\n    this._setNextState(nextState);\n\n    this._mouseMoveTracker.captureMouseMoves(event); // Focus the node so it may receive keyboard event.\n\n\n    this.root.focus();\n  },\n  _onTouchCancel: function _onTouchCancel(\n  /*object*/\n  event) {\n    event.stopPropagation();\n  },\n  _onTouchEnd: function _onTouchEnd(\n  /*object*/\n  event) {\n    event.stopPropagation();\n  },\n  _onTouchMove: function _onTouchMove(\n  /*object*/\n  event) {\n    event.stopPropagation();\n  },\n  _onTouchStart: function _onTouchStart(\n  /*object*/\n  event) {\n    event.stopPropagation();\n\n    this._onMouseDown(event);\n  },\n  _onMouseMove: function _onMouseMove(\n  /*number*/\n  deltaX,\n  /*number*/\n  deltaY) {\n    var props = this.props;\n    var delta = this.state.isHorizontal ? deltaX : deltaY;\n    delta /= this.state.scale;\n\n    this._setNextState(this._calculateState(this.state.position + delta, props.size, props.contentSize, props.orientation));\n  },\n  _onMouseMoveEnd: function _onMouseMoveEnd() {\n    this._nextState = null;\n\n    this._mouseMoveTracker.releaseMouseMoves();\n\n    this.setState({\n      isDragging: false\n    });\n  },\n  _onKeyDown: function _onKeyDown(\n  /*object*/\n  event) {\n    var keyCode = event.keyCode;\n\n    if (keyCode === _Keys2.default.TAB) {\n      // Let focus move off the scrollbar.\n      return;\n    }\n\n    var distance = KEYBOARD_SCROLL_AMOUNT;\n    var direction = 0;\n\n    if (this.state.isHorizontal) {\n      switch (keyCode) {\n        case _Keys2.default.HOME:\n          direction = -1;\n          distance = this.props.contentSize;\n          break;\n\n        case _Keys2.default.LEFT:\n          direction = -1;\n          break;\n\n        case _Keys2.default.RIGHT:\n          direction = 1;\n          break;\n\n        default:\n          return;\n      }\n    }\n\n    if (!this.state.isHorizontal) {\n      switch (keyCode) {\n        case _Keys2.default.SPACE:\n          if (event.shiftKey) {\n            direction = -1;\n          } else {\n            direction = 1;\n          }\n\n          break;\n\n        case _Keys2.default.HOME:\n          direction = -1;\n          distance = this.props.contentSize;\n          break;\n\n        case _Keys2.default.UP:\n          direction = -1;\n          break;\n\n        case _Keys2.default.DOWN:\n          direction = 1;\n          break;\n\n        case _Keys2.default.PAGE_UP:\n          direction = -1;\n          distance = this.props.size;\n          break;\n\n        case _Keys2.default.PAGE_DOWN:\n          direction = 1;\n          distance = this.props.size;\n          break;\n\n        default:\n          return;\n      }\n    }\n\n    event.preventDefault();\n    var props = this.props;\n\n    this._setNextState(this._calculateState(this.state.position + distance * direction, props.size, props.contentSize, props.orientation));\n  },\n  _onFocus: function _onFocus() {\n    this.setState({\n      focused: true\n    });\n  },\n  _onBlur: function _onBlur() {\n    this.setState({\n      focused: false\n    });\n  },\n  _blur: function _blur() {\n    var el = _ReactDOM2.default.findDOMNode(this);\n\n    if (!el) {\n      return;\n    }\n\n    try {\n      this._onBlur();\n\n      el.blur();\n    } catch (oops) {// pass\n    }\n  },\n  _setNextState: function _setNextState(\n  /*object*/\n  nextState,\n  /*?object*/\n  props) {\n    props = props || this.props;\n    var controlledPosition = props.position;\n    var willScroll = this.state.position !== nextState.position;\n\n    if (controlledPosition === undefined) {\n      var callback = willScroll ? this._didScroll : undefined;\n      this.setState(nextState, callback);\n    } else if (controlledPosition === nextState.position) {\n      this.setState(nextState);\n    } else {\n      // Scrolling is controlled. Don't update the state and let the owner\n      // to update the scrollbar instead.\n      if (nextState.position !== undefined && nextState.position !== this.state.position) {\n        this.props.onScroll(nextState.position);\n      }\n\n      return;\n    }\n\n    if (willScroll && _lastScrolledScrollbar !== this) {\n      _lastScrolledScrollbar && _lastScrolledScrollbar._blur();\n      _lastScrolledScrollbar = this;\n    }\n  },\n  _didScroll: function _didScroll() {\n    this.props.onScroll(this.state.position);\n  }\n});\nScrollbar.KEYBOARD_SCROLL_AMOUNT = KEYBOARD_SCROLL_AMOUNT;\nScrollbar.SIZE = parseInt((0, _cssVar2.default)('scrollbar-size'), 10);\nScrollbar.OFFSET = 1;\nmodule.exports = Scrollbar;","map":null,"metadata":{},"sourceType":"script"}