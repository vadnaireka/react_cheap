{"ast":null,"code":"'use strict';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FixedDataTable\n * @typechecks\n * @noflow\n */\n\n/*eslint no-bitwise:1*/\n\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _createReactClass = require('create-react-class');\n\nvar _createReactClass2 = _interopRequireDefault(_createReactClass);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _ReactComponentWithPureRenderMixin = require('./ReactComponentWithPureRenderMixin');\n\nvar _ReactComponentWithPureRenderMixin2 = _interopRequireDefault(_ReactComponentWithPureRenderMixin);\n\nvar _ReactWheelHandler = require('./ReactWheelHandler');\n\nvar _ReactWheelHandler2 = _interopRequireDefault(_ReactWheelHandler);\n\nvar _ReactTouchHandler = require('./ReactTouchHandler');\n\nvar _ReactTouchHandler2 = _interopRequireDefault(_ReactTouchHandler);\n\nvar _Scrollbar = require('./Scrollbar');\n\nvar _Scrollbar2 = _interopRequireDefault(_Scrollbar);\n\nvar _FixedDataTableBufferedRows = require('./FixedDataTableBufferedRows');\n\nvar _FixedDataTableBufferedRows2 = _interopRequireDefault(_FixedDataTableBufferedRows);\n\nvar _FixedDataTableColumnResizeHandle = require('./FixedDataTableColumnResizeHandle');\n\nvar _FixedDataTableColumnResizeHandle2 = _interopRequireDefault(_FixedDataTableColumnResizeHandle);\n\nvar _FixedDataTableRow = require('./FixedDataTableRow');\n\nvar _FixedDataTableRow2 = _interopRequireDefault(_FixedDataTableRow);\n\nvar _FixedDataTableScrollHelper = require('./FixedDataTableScrollHelper');\n\nvar _FixedDataTableScrollHelper2 = _interopRequireDefault(_FixedDataTableScrollHelper);\n\nvar _FixedDataTableWidthHelper = require('./FixedDataTableWidthHelper');\n\nvar _FixedDataTableWidthHelper2 = _interopRequireDefault(_FixedDataTableWidthHelper);\n\nvar _FixedDataTableEventHelper = require('./FixedDataTableEventHelper');\n\nvar _FixedDataTableEventHelper2 = _interopRequireDefault(_FixedDataTableEventHelper);\n\nvar _cx = require('./cx');\n\nvar _cx2 = _interopRequireDefault(_cx);\n\nvar _debounceCore = require('./debounceCore');\n\nvar _debounceCore2 = _interopRequireDefault(_debounceCore);\n\nvar _emptyFunction = require('./emptyFunction');\n\nvar _emptyFunction2 = _interopRequireDefault(_emptyFunction);\n\nvar _invariant = require('./invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _joinClasses = require('./joinClasses');\n\nvar _joinClasses2 = _interopRequireDefault(_joinClasses);\n\nvar _shallowEqual = require('./shallowEqual');\n\nvar _shallowEqual2 = _interopRequireDefault(_shallowEqual);\n\nvar _FixedDataTableTranslateDOMPosition = require('./FixedDataTableTranslateDOMPosition');\n\nvar _FixedDataTableTranslateDOMPosition2 = _interopRequireDefault(_FixedDataTableTranslateDOMPosition);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ReactChildren = _react2.default.Children;\nvar EMPTY_OBJECT = {};\nvar BORDER_HEIGHT = 1;\nvar HEADER = 'header';\nvar FOOTER = 'footer';\nvar CELL = 'cell';\nvar ARROW_SCROLL_SPEED = 25;\nvar DRAG_SCROLL_SPEED = 15;\nvar DRAG_SCROLL_BUFFER = 100;\n/**\n * Data grid component with fixed or scrollable header and columns.\n *\n * The layout of the data table is as follows:\n *\n * ```\n * +---------------------------------------------------+\n * | Fixed Column Group    | Scrollable Column Group   |\n * | Header                | Header                    |\n * |                       |                           |\n * +---------------------------------------------------+\n * |                       |                           |\n * | Fixed Header Columns  | Scrollable Header Columns |\n * |                       |                           |\n * +-----------------------+---------------------------+\n * |                       |                           |\n * | Fixed Body Columns    | Scrollable Body Columns   |\n * |                       |                           |\n * +-----------------------+---------------------------+\n * |                       |                           |\n * | Fixed Footer Columns  | Scrollable Footer Columns |\n * |                       |                           |\n * +-----------------------+---------------------------+\n * ```\n *\n * - Fixed Column Group Header: These are the headers for a group\n *   of columns if included in the table that do not scroll\n *   vertically or horizontally.\n *\n * - Scrollable Column Group Header: The header for a group of columns\n *   that do not move while scrolling vertically, but move horizontally\n *   with the horizontal scrolling.\n *\n * - Fixed Header Columns: The header columns that do not move while scrolling\n *   vertically or horizontally.\n *\n * - Scrollable Header Columns: The header columns that do not move\n *   while scrolling vertically, but move horizontally with the horizontal\n *   scrolling.\n *\n * - Fixed Body Columns: The body columns that do not move while scrolling\n *   horizontally, but move vertically with the vertical scrolling.\n *\n * - Scrollable Body Columns: The body columns that move while scrolling\n *   vertically or horizontally.\n */\n\nvar FixedDataTable = (0, _createReactClass2.default)({\n  displayName: 'FixedDataTable',\n  propTypes: {\n    /**\n     * Pixel width of table. If all columns do not fit,\n     * a horizontal scrollbar will appear.\n     */\n    width: _propTypes2.default.number.isRequired,\n\n    /**\n     * Pixel height of table. If all rows do not fit,\n     * a vertical scrollbar will appear.\n     *\n     * Either `height` or `maxHeight` must be specified.\n     */\n    height: _propTypes2.default.number,\n\n    /**\n     * Class name to be passed into parent container\n     */\n    className: _propTypes2.default.string,\n\n    /**\n     * Maximum pixel height of table. If all rows do not fit,\n     * a vertical scrollbar will appear.\n     *\n     * Either `height` or `maxHeight` must be specified.\n     */\n    maxHeight: _propTypes2.default.number,\n\n    /**\n     * Pixel height of table's owner, this is used in a managed scrolling\n     * situation when you want to slide the table up from below the fold\n     * without having to constantly update the height on every scroll tick.\n     * Instead, vary this property on scroll. By using `ownerHeight`, we\n     * over-render the table while making sure the footer and horizontal\n     * scrollbar of the table are visible when the current space for the table\n     * in view is smaller than the final, over-flowing height of table. It\n     * allows us to avoid resizing and reflowing table when it is moving in the\n     * view.\n     *\n     * This is used if `ownerHeight < height` (or `maxHeight`).\n     */\n    ownerHeight: _propTypes2.default.number,\n    overflowX: _propTypes2.default.oneOf(['hidden', 'auto']),\n    overflowY: _propTypes2.default.oneOf(['hidden', 'auto']),\n\n    /**\n     * Boolean flag indicating of touch scrolling should be enabled\n     * This feature is current in beta and may have bugs\n     */\n    touchScrollEnabled: _propTypes2.default.bool,\n\n    /**\n     * Boolean flags to control if scrolling with keys is enabled\n     */\n    keyboardScrollEnabled: _propTypes2.default.bool,\n    keyboardPageEnabled: _propTypes2.default.bool,\n\n    /**\n     * Hide the scrollbar but still enable scroll functionality\n     */\n    showScrollbarX: _propTypes2.default.bool,\n    showScrollbarY: _propTypes2.default.bool,\n\n    /**\n     * Callback when horizontally scrolling the grid.\n     *\n     * Return false to stop propagation.\n     */\n    onHorizontalScroll: _propTypes2.default.func,\n\n    /**\n     * Callback when vertically scrolling the grid.\n     *\n     * Return false to stop propagation.\n     */\n    onVerticalScroll: _propTypes2.default.func,\n\n    /**\n     * Number of rows in the table.\n     */\n    rowsCount: _propTypes2.default.number.isRequired,\n\n    /**\n     * Pixel height of rows unless `rowHeightGetter` is specified and returns\n     * different value.\n     */\n    rowHeight: _propTypes2.default.number.isRequired,\n\n    /**\n     * If specified, `rowHeightGetter(index)` is called for each row and the\n     * returned value overrides `rowHeight` for particular row.\n     */\n    rowHeightGetter: _propTypes2.default.func,\n\n    /**\n     * Pixel height of sub-row unless `subRowHeightGetter` is specified and returns\n     * different value.  Defaults to 0 and no sub-row being displayed.\n     */\n    subRowHeight: _propTypes2.default.number,\n\n    /**\n     * If specified, `subRowHeightGetter(index)` is called for each row and the\n     * returned value overrides `subRowHeight` for particular row.\n     */\n    subRowHeightGetter: _propTypes2.default.func,\n\n    /**\n     * The row expanded for table row.\n     * This can either be a React element, or a function that generates\n     * a React Element. By default, the React element passed in can expect to\n     * receive the following props:\n     *\n     * ```\n     * props: {\n     *   rowIndex; number // (the row index)\n     *   height: number // (supplied from the Table or rowHeightGetter)\n     *   width: number // (supplied from the Table)\n     * }\n     * ```\n     *\n     * Because you are passing in your own React element, you can feel free to\n     * pass in whatever props you may want or need.\n     *\n     * If you pass in a function, you will receive the same props object as the\n     * first argument.\n     */\n    rowExpanded: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.func]),\n\n    /**\n     * To get any additional CSS classes that should be added to a row,\n     * `rowClassNameGetter(index)` is called.\n     */\n    rowClassNameGetter: _propTypes2.default.func,\n\n    /**\n     * If specified, `rowKeyGetter(index)` is called for each row and the\n     * returned value overrides `key` for the particular row.\n     */\n    rowKeyGetter: _propTypes2.default.func,\n\n    /**\n     * Pixel height of the column group header.\n     */\n    groupHeaderHeight: _propTypes2.default.number,\n\n    /**\n     * Pixel height of header.\n     */\n    headerHeight: _propTypes2.default.number.isRequired,\n\n    /**\n     * Pixel height of fixedDataTableCellGroupLayout/cellGroupWrapper.\n     * Default is headerHeight and groupHeaderHeight.\n     *\n     * This can be used with CSS to make a header cell span both the group & normal header row.\n     * Setting this to a value larger than height will cause the content to\n     * overflow the height. This is useful when adding a 2nd table as the group\n     * header and vertically merging the 2 headers when a column is not part\n     * of a group. Here are the necessary CSS changes:\n     *\n     * Both headers:\n     *  - cellGroupWrapper needs overflow-x: hidden and pointer-events: none\n     *  - cellGroup needs pointer-events: auto to reenable them on child els\n     * Group header:\n     *  - Layout/main needs overflow: visible and a higher z-index\n     *  - CellLayout/main needs overflow-y: visible\n     *  - cellGroup needs overflow: visible\n     */\n    cellGroupWrapperHeight: _propTypes2.default.number,\n\n    /**\n     * Pixel height of footer.\n     */\n    footerHeight: _propTypes2.default.number,\n\n    /**\n     * Value of horizontal scroll.\n     */\n    scrollLeft: _propTypes2.default.number,\n\n    /**\n     * Index of column to scroll to.\n     */\n    scrollToColumn: _propTypes2.default.number,\n\n    /**\n     * Value of vertical scroll.\n     */\n    scrollTop: _propTypes2.default.number,\n\n    /**\n     * Index of row to scroll to.\n     */\n    scrollToRow: _propTypes2.default.number,\n\n    /**\n     * Callback that is called when scrolling starts with current horizontal\n     * and vertical scroll values.\n     */\n    onScrollStart: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when scrolling ends or stops with new horizontal\n     * and vertical scroll values.\n     */\n    onScrollEnd: _propTypes2.default.func,\n\n    /**\n     * If enabled scroll events will not be propagated outside of the table.\n     */\n    stopScrollPropagation: _propTypes2.default.bool,\n\n    /**\n     * Callback that is called when `rowHeightGetter` returns a different height\n     * for a row than the `rowHeight` prop. This is necessary because initially\n     * table estimates heights of some parts of the content.\n     */\n    onContentHeightChange: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when a row is clicked.\n     */\n    onRowClick: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when a row is double clicked.\n     */\n    onRowDoubleClick: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when a contextual-menu event happens on a row.\n     */\n    onRowContextMenu: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when a mouse-down event happens on a row.\n     */\n    onRowMouseDown: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when a mouse-up event happens on a row.\n     */\n    onRowMouseUp: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when a mouse-enter event happens on a row.\n     */\n    onRowMouseEnter: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when a mouse-leave event happens on a row.\n     */\n    onRowMouseLeave: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when a touch-start event happens on a row.\n     */\n    onRowTouchStart: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when a touch-end event happens on a row.\n     */\n    onRowTouchEnd: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when a touch-move event happens on a row.\n     */\n    onRowTouchMove: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when resizer has been released\n     * and column needs to be updated.\n     *\n     * Required if the isResizable property is true on any column.\n     *\n     * ```\n     * function(\n     *   newColumnWidth: number,\n     *   columnKey: string,\n     * )\n     * ```\n     */\n    onColumnResizeEndCallback: _propTypes2.default.func,\n\n    /**\n     * Callback that is called when reordering has been completed\n     * and columns need to be updated.\n     *\n     * ```\n     * function(\n     *   event {\n     *     columnBefore: string|undefined, // the column before the new location of this one\n     *     columnAfter: string|undefined,  // the column after the new location of this one\n     *     reorderColumn: string,          // the column key that was just reordered\n     *   }\n     * )\n     * ```\n     */\n    onColumnReorderEndCallback: _propTypes2.default.func,\n\n    /**\n     * Whether a column is currently being resized.\n     */\n    isColumnResizing: _propTypes2.default.bool,\n\n    /**\n     * Whether columns are currently being reordered.\n     */\n    isColumnReordering: _propTypes2.default.bool,\n\n    /**\n     * The number of rows outside the viewport to prerender. Defaults to roughly\n     * half of the number of visible rows.\n     */\n    bufferRowCount: _propTypes2.default.number\n  },\n  getDefaultProps: function getDefaultProps()\n  /*object*/\n  {\n    return {\n      footerHeight: 0,\n      groupHeaderHeight: 0,\n      headerHeight: 0,\n      showScrollbarX: true,\n      showScrollbarY: true,\n      touchScrollEnabled: false,\n      keyboardScrollEnabled: false,\n      keyboardPageEnabled: false,\n      stopScrollPropagation: false\n    };\n  },\n  componentWillMount: function componentWillMount() {\n    var props = this.props;\n    var viewportHeight = (props.height === undefined ? props.maxHeight : props.height) - (props.headerHeight || 0) - (props.footerHeight || 0) - (props.groupHeaderHeight || 0);\n    this._scrollHelper = new _FixedDataTableScrollHelper2.default(props.rowsCount, props.rowHeight, viewportHeight, props.rowHeightGetter, props.subRowHeight, props.subRowHeightGetter);\n    this._didScrollStop = (0, _debounceCore2.default)(this._didScrollStopSync, 200, this);\n    this._wheelHandler = new _ReactWheelHandler2.default(this._onScroll, this._shouldHandleWheelX, this._shouldHandleWheelY, props.stopScrollPropagation);\n    this._touchHandler = new _ReactTouchHandler2.default(this._onScroll, this._shouldHandleTouchX, this._shouldHandleTouchY, props.stopScrollPropagation);\n    this.setState(this._calculateState(props));\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    this._divRef && this._divRef.removeEventListener('wheel', this._wheelHandler.onWheel, {\n      passive: false\n    });\n    this._wheelHandler = null;\n    this._touchHandler = null; // Cancel any pending debounced scroll handling and handle immediately.\n\n    this._didScrollStop.reset();\n\n    this._didScrollStopSync();\n  },\n  _shouldHandleTouchX: function _shouldHandleTouchX(\n  /*number*/\n  delta)\n  /*boolean*/\n  {\n    return this.props.touchScrollEnabled && this._shouldHandleWheelX(delta);\n  },\n  _shouldHandleTouchY: function _shouldHandleTouchY(\n  /*number*/\n  delta)\n  /*boolean*/\n  {\n    return this.props.touchScrollEnabled && this._shouldHandleWheelY(delta);\n  },\n  _shouldHandleWheelX: function _shouldHandleWheelX(\n  /*number*/\n  delta)\n  /*boolean*/\n  {\n    if (this.props.overflowX === 'hidden') {\n      return false;\n    }\n\n    delta = Math.round(delta);\n\n    if (delta === 0) {\n      return false;\n    }\n\n    return delta < 0 && this.state.scrollX > 0 || delta >= 0 && this.state.scrollX < this.state.maxScrollX;\n  },\n  _shouldHandleWheelY: function _shouldHandleWheelY(\n  /*number*/\n  delta)\n  /*boolean*/\n  {\n    if (this.props.overflowY === 'hidden' || delta === 0) {\n      return false;\n    }\n\n    delta = Math.round(delta);\n\n    if (delta === 0) {\n      return false;\n    }\n\n    return delta < 0 && this.state.scrollY > 0 || delta >= 0 && this.state.scrollY < this.state.maxScrollY;\n  },\n  _onKeyDown: function _onKeyDown(event) {\n    if (this.props.keyboardPageEnabled) {\n      switch (event.key) {\n        case 'PageDown':\n          this._onScroll(0, this._scrollbarYHeight);\n\n          event.preventDefault();\n          break;\n\n        case 'PageUp':\n          this._onScroll(0, this._scrollbarYHeight * -1);\n\n          event.preventDefault();\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (this.props.keyboardScrollEnabled) {\n      switch (event.key) {\n        case 'ArrowDown':\n          this._onScroll(0, ARROW_SCROLL_SPEED);\n\n          event.preventDefault();\n          break;\n\n        case 'ArrowUp':\n          this._onScroll(0, ARROW_SCROLL_SPEED * -1);\n\n          event.preventDefault();\n          break;\n\n        case 'ArrowRight':\n          this._onScroll(ARROW_SCROLL_SPEED, 0);\n\n          event.preventDefault();\n          break;\n\n        case 'ArrowLeft':\n          this._onScroll(ARROW_SCROLL_SPEED * -1, 0);\n\n          event.preventDefault();\n          break;\n\n        default:\n          break;\n      }\n    }\n  },\n  _reportContentHeight: function _reportContentHeight() {\n    var scrollContentHeight = this.state.scrollContentHeight;\n    var reservedHeight = this.state.reservedHeight;\n    var requiredHeight = scrollContentHeight + reservedHeight;\n    var contentHeight;\n    var useMaxHeight = this.props.height === undefined;\n\n    if (useMaxHeight && this.props.maxHeight > requiredHeight) {\n      contentHeight = requiredHeight;\n    } else if (this.state.height > requiredHeight && this.props.ownerHeight) {\n      contentHeight = Math.max(requiredHeight, this.props.ownerHeight);\n    } else {\n      contentHeight = this.state.height + this.state.maxScrollY;\n    }\n\n    if (contentHeight !== this._contentHeight && this.props.onContentHeightChange) {\n      this.props.onContentHeightChange(contentHeight);\n    }\n\n    this._contentHeight = contentHeight;\n  },\n  componentDidMount: function componentDidMount() {\n    this._divRef && this._divRef.addEventListener('wheel', this._wheelHandler.onWheel, {\n      passive: false\n    });\n\n    this._reportContentHeight();\n  },\n  componentWillReceiveProps: function componentWillReceiveProps(\n  /*object*/\n  nextProps) {\n    // In the case of controlled scrolling, notify.\n    if (this.props.ownerHeight !== nextProps.ownerHeight || this.props.scrollTop !== nextProps.scrollTop || this.props.scrollLeft !== nextProps.scrollLeft) {\n      this._didScrollStart();\n    }\n\n    this.setState(this._calculateState(nextProps, this.state), this._didScrollStop);\n  },\n  componentDidUpdate: function componentDidUpdate() {\n    this._reportContentHeight();\n  },\n  _onRef: function _onRef(div) {\n    this._divRef = div;\n\n    if (this.props.stopReactWheelPropagation) {\n      this._wheelHandler.setRoot(div);\n    }\n  },\n  render: function render()\n  /*object*/\n  {\n    var state = this.state;\n    var props = this.props;\n    var onColumnReorder = props.onColumnReorderEndCallback ? this._onColumnReorder : null;\n    var maxScrollY = this.state.maxScrollY;\n    var showScrollbarX = state.maxScrollX > 0 && state.overflowX !== 'hidden' && state.showScrollbarX !== false;\n\n    var showScrollbarY = this._showScrollbarY(state);\n\n    var ariaAttributes = this._calculateAriaAttributes(state);\n\n    var groupHeader;\n\n    if (state.useGroupHeader) {\n      groupHeader = _react2.default.createElement(_FixedDataTableRow2.default, {\n        key: 'group_header',\n        isScrolling: this._isScrolling,\n        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/header'), (0, _cx2.default)('public/fixedDataTable/header')),\n        width: state.width,\n        height: state.groupHeaderHeight,\n        cellGroupWrapperHeight: state.cellGroupWrapperHeight,\n        index: 0,\n        zIndex: 1,\n        offsetTop: 0,\n        scrollLeft: state.scrollX,\n        fixedColumns: state.groupHeaderFixedColumns,\n        fixedRightColumns: state.groupHeaderFixedRightColumns,\n        scrollableColumns: state.groupHeaderScrollableColumns,\n        onColumnResize: this._onColumnResize,\n        onColumnReorder: onColumnReorder,\n        onColumnReorderMove: this._onColumnReorderMove,\n        showScrollbarY: showScrollbarY,\n        isHeaderOrFooter: true,\n        ariaIndex: ariaAttributes.groupHeaderAriaIndex\n      });\n    }\n\n    var scrollbarXHeight = showScrollbarX ? _Scrollbar2.default.SIZE : 0;\n    var scrollbarYHeight = state.height - scrollbarXHeight - 2 * BORDER_HEIGHT - state.footerHeight;\n    var headerOffsetTop = state.useGroupHeader ? state.groupHeaderHeight : 0;\n    var bodyOffsetTop = headerOffsetTop + state.headerHeight;\n    scrollbarYHeight -= bodyOffsetTop;\n    var bottomSectionOffset = 0;\n    var footOffsetTop = props.maxHeight != null ? bodyOffsetTop + state.bodyHeight : bodyOffsetTop + scrollbarYHeight;\n    var rowsContainerHeight = footOffsetTop + state.footerHeight;\n\n    if (props.ownerHeight !== undefined && props.ownerHeight < state.height) {\n      bottomSectionOffset = props.ownerHeight - state.height;\n      footOffsetTop = Math.min(footOffsetTop, props.ownerHeight - state.footerHeight - scrollbarXHeight);\n      scrollbarYHeight = Math.max(0, footOffsetTop - bodyOffsetTop);\n    }\n\n    this._scrollbarYHeight = scrollbarYHeight;\n    var verticalScrollbar;\n\n    if (showScrollbarY) {\n      verticalScrollbar = _react2.default.createElement(_Scrollbar2.default, {\n        size: scrollbarYHeight,\n        contentSize: scrollbarYHeight + maxScrollY,\n        onScroll: this._onVerticalScroll,\n        verticalTop: bodyOffsetTop,\n        position: state.scrollY,\n        touchEnabled: state.touchScrollEnabled\n      });\n    }\n\n    var horizontalScrollbar;\n\n    if (showScrollbarX) {\n      var scrollbarXWidth = state.width;\n      horizontalScrollbar = _react2.default.createElement(HorizontalScrollbar, {\n        contentSize: scrollbarXWidth + state.maxScrollX,\n        offset: bottomSectionOffset,\n        onScroll: this._onHorizontalScroll,\n        position: state.scrollX,\n        size: scrollbarXWidth,\n        touchEnabled: state.touchScrollEnabled\n      });\n    }\n\n    var dragKnob = _react2.default.createElement(_FixedDataTableColumnResizeHandle2.default, {\n      height: state.height,\n      initialWidth: state.columnResizingData.width || 0,\n      minWidth: state.columnResizingData.minWidth || 0,\n      maxWidth: state.columnResizingData.maxWidth || Number.MAX_VALUE,\n      visible: !!state.isColumnResizing,\n      leftOffset: state.columnResizingData.left || 0,\n      knobHeight: state.headerHeight,\n      initialEvent: state.columnResizingData.initialEvent,\n      onColumnResizeEnd: props.onColumnResizeEndCallback,\n      columnKey: state.columnResizingData.key,\n      touchEnabled: state.touchScrollEnabled\n    });\n\n    var footer = null;\n\n    if (state.footerHeight) {\n      footer = _react2.default.createElement(_FixedDataTableRow2.default, {\n        key: 'footer',\n        isScrolling: this._isScrolling,\n        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/footer'), (0, _cx2.default)('public/fixedDataTable/footer')),\n        width: state.width,\n        height: state.footerHeight,\n        index: -1,\n        zIndex: 1,\n        offsetTop: footOffsetTop,\n        fixedColumns: state.footFixedColumns,\n        fixedRightColumns: state.footFixedRightColumns,\n        scrollableColumns: state.footScrollableColumns,\n        scrollLeft: state.scrollX,\n        showScrollbarY: showScrollbarY,\n        isHeaderOrFooter: true,\n        ariaIndex: ariaAttributes.footerAriaIndex\n      });\n    }\n\n    var rows = this._renderRows(bodyOffsetTop, ariaAttributes.ariaRowIndexOffset);\n\n    var header = _react2.default.createElement(_FixedDataTableRow2.default, {\n      key: 'header',\n      isScrolling: this._isScrolling,\n      className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/header'), (0, _cx2.default)('public/fixedDataTable/header')),\n      width: state.width,\n      height: state.headerHeight,\n      cellGroupWrapperHeight: state.cellGroupWrapperHeight,\n      index: -1,\n      zIndex: 1,\n      offsetTop: headerOffsetTop,\n      scrollLeft: state.scrollX,\n      fixedColumns: state.headFixedColumns,\n      fixedRightColumns: state.headFixedRightColumns,\n      scrollableColumns: state.headScrollableColumns,\n      touchEnabled: state.touchScrollEnabled,\n      onColumnResize: this._onColumnResize,\n      onColumnReorder: onColumnReorder,\n      onColumnReorderMove: this._onColumnReorderMove,\n      onColumnReorderEnd: this._onColumnReorderEnd,\n      isColumnReordering: !!state.isColumnReordering,\n      columnReorderingData: state.columnReorderingData,\n      showScrollbarY: showScrollbarY,\n      isHeaderOrFooter: true,\n      ariaIndex: ariaAttributes.headerAriaIndex\n    });\n\n    var topShadow;\n    var bottomShadow;\n\n    if (state.scrollY) {\n      topShadow = _react2.default.createElement('div', {\n        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/topShadow'), (0, _cx2.default)('public/fixedDataTable/topShadow')),\n        style: {\n          top: bodyOffsetTop\n        }\n      });\n    }\n\n    if (state.ownerHeight != null && state.ownerHeight < state.height && state.scrollContentHeight + state.reservedHeight > state.ownerHeight || state.scrollY < maxScrollY) {\n      bottomShadow = _react2.default.createElement('div', {\n        className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/bottomShadow'), (0, _cx2.default)('public/fixedDataTable/bottomShadow')),\n        style: {\n          top: footOffsetTop\n        }\n      });\n    }\n\n    var tabIndex = null;\n\n    if (this.props.keyboardPageEnabled || this.props.keyboardScrollEnabled) {\n      tabIndex = 0;\n    }\n\n    return _react2.default.createElement('div', {\n      className: (0, _joinClasses2.default)(this.state.className, (0, _cx2.default)('fixedDataTableLayout/main'), (0, _cx2.default)('public/fixedDataTable/main')),\n      role: 'grid',\n      'aria-rowcount': ariaAttributes.ariaRowCount,\n      tabIndex: tabIndex,\n      onKeyDown: this._onKeyDown,\n      onTouchStart: this._touchHandler.onTouchStart,\n      onTouchEnd: this._touchHandler.onTouchEnd,\n      onTouchMove: this._touchHandler.onTouchMove,\n      onTouchCancel: this._touchHandler.onTouchCancel,\n      ref: this._onRef,\n      style: {\n        height: state.height,\n        width: state.width\n      }\n    }, _react2.default.createElement('div', {\n      className: (0, _cx2.default)('fixedDataTableLayout/rowsContainer'),\n      style: {\n        height: rowsContainerHeight,\n        width: state.width\n      }\n    }, dragKnob, groupHeader, header, rows, footer, topShadow, bottomShadow), verticalScrollbar, horizontalScrollbar);\n  },\n  _renderRows: function _renderRows(\n  /*number*/\n  offsetTop,\n  /*number*/\n  ariaIndexOffset)\n  /*object*/\n  {\n    var state = this.state;\n\n    var showScrollbarY = this._showScrollbarY(state);\n\n    return _react2.default.createElement(_FixedDataTableBufferedRows2.default, {\n      ariaIndexOffset: ariaIndexOffset,\n      isScrolling: this._isScrolling,\n      defaultRowHeight: state.rowHeight,\n      firstRowIndex: state.firstRowIndex,\n      firstRowOffset: state.firstRowOffset,\n      fixedColumns: state.bodyFixedColumns,\n      fixedRightColumns: state.bodyFixedRightColumns,\n      height: state.bodyHeight,\n      offsetTop: offsetTop,\n      onRowClick: state.onRowClick,\n      onRowDoubleClick: state.onRowDoubleClick,\n      onRowContextMenu: state.onRowContextMenu,\n      onRowMouseDown: state.onRowMouseDown,\n      onRowMouseUp: state.onRowMouseUp,\n      onRowMouseEnter: state.onRowMouseEnter,\n      onRowMouseLeave: state.onRowMouseLeave,\n      onRowTouchStart: state.touchScrollEnabled ? state.onRowTouchStart : null,\n      onRowTouchEnd: state.touchScrollEnabled ? state.onRowTouchEnd : null,\n      onRowTouchMove: state.touchScrollEnabled ? state.onRowTouchMove : null,\n      rowClassNameGetter: state.rowClassNameGetter,\n      rowsCount: state.rowsCount,\n      rowGetter: state.rowGetter,\n      rowHeightGetter: state.rowHeightGetter,\n      subRowHeight: state.subRowHeight,\n      subRowHeightGetter: state.subRowHeightGetter,\n      rowExpanded: state.rowExpanded,\n      rowKeyGetter: state.rowKeyGetter,\n      scrollLeft: state.scrollX,\n      scrollableColumns: state.bodyScrollableColumns,\n      showLastRowBorder: true,\n      width: state.width,\n      rowPositionGetter: this._scrollHelper.getRowPosition,\n      bufferRowCount: this.state.bufferRowCount,\n      showScrollbarY: showScrollbarY\n    });\n  },\n\n  /**\n   * This is needed to calculate the aria attributes for the rows and grid. Specifically\n   * the aria-rowindex and aria-rowcount. Note that aria-rowindex is 1-indexed based.\n   */\n  _calculateAriaAttributes: function _calculateAriaAttributes(\n  /*object*/\n  state)\n  /*object*/\n  {\n    // Default index values\n    var groupHeaderAriaIndex = 1; // assuming no group header\n\n    var headerAriaIndex = 1; // assuming no group header\n\n    var footerAriaIndex = state.rowsCount + 2; // assuming no group header or footer\n\n    var ariaRowCount = state.rowsCount + 1; // offset to add to rowIndex (0-indexed) to calculate aria-rowindex\n    // Need to add 1 for the header\n\n    var ariaRowIndexOffset = 2;\n\n    if (state.useGroupHeader) {\n      headerAriaIndex++;\n      ariaRowCount++;\n      footerAriaIndex++;\n      ariaRowIndexOffset++;\n    }\n\n    if (state.footerHeight) {\n      ariaRowCount++;\n    }\n\n    return {\n      groupHeaderAriaIndex: groupHeaderAriaIndex,\n      headerAriaIndex: headerAriaIndex,\n      footerAriaIndex: footerAriaIndex,\n      ariaRowCount: ariaRowCount,\n      ariaRowIndexOffset: ariaRowIndexOffset\n    };\n  },\n\n  /**\n   * This is called when a cell that is in the header of a column has its\n   * resizer knob clicked on. It displays the resizer and puts in the correct\n   * location on the table.\n   */\n  _onColumnResize: function _onColumnResize(\n  /*number*/\n  combinedWidth,\n  /*number*/\n  leftOffset,\n  /*number*/\n  cellWidth,\n  /*?number*/\n  cellMinWidth,\n  /*?number*/\n  cellMaxWidth,\n  /*number|string*/\n  columnKey,\n  /*object*/\n  event) {\n    var coordinates = _FixedDataTableEventHelper2.default.getCoordinatesFromEvent(event);\n\n    var x = coordinates.x;\n    var y = coordinates.y;\n    this.setState({\n      isColumnResizing: true,\n      columnResizingData: {\n        left: leftOffset + combinedWidth - cellWidth,\n        width: cellWidth,\n        minWidth: cellMinWidth,\n        maxWidth: cellMaxWidth,\n        initialEvent: {\n          clientX: x,\n          clientY: y,\n          preventDefault: _emptyFunction2.default\n        },\n        key: columnKey\n      }\n    });\n  },\n  _onColumnReorder: function _onColumnReorder(\n  /*string*/\n  columnKey,\n  /*number*/\n  width,\n  /*number*/\n  left,\n  /*object*/\n  event) {\n    // No native support in IE11 for find, findIndex, or includes, so using some.\n    var isFixed = this.state.headFixedColumns.some(function (column) {\n      return column.props.columnKey === columnKey;\n    });\n    this.setState({\n      isColumnReordering: true,\n      columnReorderingData: {\n        dragDistance: 0,\n        isFixed: isFixed,\n        scrollStart: this.state.scrollX,\n        columnKey: columnKey,\n        columnWidth: width,\n        originalLeft: left,\n        columnsBefore: [],\n        columnsAfter: []\n      }\n    });\n  },\n  _onColumnReorderMove: function _onColumnReorderMove(\n  /*number*/\n  deltaX) {\n    //NOTE Need to clone this object when use pureRendering\n    var reorderingData = _extends({}, this.state.columnReorderingData);\n\n    reorderingData.dragDistance = deltaX;\n    reorderingData.columnBefore = undefined;\n    reorderingData.columnAfter = undefined;\n    var isFixedColumn = this.state.columnReorderingData.isFixed;\n    var scrollX = this.state.scrollX;\n\n    if (!isFixedColumn) {\n      //Relative dragX position on scroll\n      var dragX = reorderingData.originalLeft - reorderingData.scrollStart + reorderingData.dragDistance;\n      var fixedColumnsWidth = this.state.bodyFixedColumns.reduce(function (sum, column) {\n        return sum + column.props.width;\n      }, 0);\n      var relativeWidth = this.props.width - fixedColumnsWidth; //Scroll the table left or right if we drag near the edges of the table\n\n      if (dragX > relativeWidth - DRAG_SCROLL_BUFFER) {\n        scrollX = Math.min(scrollX + DRAG_SCROLL_SPEED, this.state.maxScrollX);\n      } else if (dragX <= DRAG_SCROLL_BUFFER) {\n        scrollX = Math.max(scrollX - DRAG_SCROLL_SPEED, 0);\n      }\n\n      reorderingData.dragDistance += this.state.scrollX - reorderingData.scrollStart;\n    }\n\n    this.setState({\n      scrollX: scrollX,\n      columnReorderingData: reorderingData\n    });\n  },\n  _onColumnReorderEnd: function _onColumnReorderEnd(\n  /*object*/\n  props,\n  /*object*/\n  event) {\n    var columnBefore = this.state.columnReorderingData.columnBefore;\n    var columnAfter = this.state.columnReorderingData.columnAfter;\n    var reorderColumn = this.state.columnReorderingData.columnKey;\n    var cancelReorder = this.state.columnReorderingData.cancelReorder;\n    this.setState({\n      isColumnReordering: false,\n      columnReorderingData: {}\n    });\n\n    if (cancelReorder) {\n      return;\n    }\n\n    this.props.onColumnReorderEndCallback({\n      columnBefore: columnBefore,\n      columnAfter: columnAfter,\n      reorderColumn: reorderColumn\n    });\n    var onHorizontalScroll = this.props.onHorizontalScroll;\n\n    if (this.state.columnReorderingData.scrollStart !== this.state.scrollX && onHorizontalScroll) {\n      onHorizontalScroll(this.state.scrollX);\n    }\n\n    ;\n  },\n  _areColumnSettingsIdentical: function _areColumnSettingsIdentical(oldColumns, newColumns) {\n    if (oldColumns.length !== newColumns.length) {\n      return false;\n    }\n\n    for (var index = 0; index < oldColumns.length; ++index) {\n      if (!(0, _shallowEqual2.default)(oldColumns[index].props, newColumns[index].props)) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  _populateColumnsAndColumnData: function _populateColumnsAndColumnData(columns, columnGroups, oldState) {\n    var canReuseColumnSettings = false;\n    var canReuseColumnGroupSettings = false;\n\n    if (oldState && oldState.columns) {\n      canReuseColumnSettings = this._areColumnSettingsIdentical(columns, oldState.columns);\n    }\n\n    if (oldState && oldState.columnGroups && columnGroups) {\n      canReuseColumnGroupSettings = this._areColumnSettingsIdentical(columnGroups, oldState.columnGroups);\n    }\n\n    var columnInfo = {};\n\n    if (canReuseColumnSettings) {\n      columnInfo.bodyFixedColumns = oldState.bodyFixedColumns;\n      columnInfo.bodyFixedRightColumns = oldState.bodyFixedRightColumns;\n      columnInfo.bodyScrollableColumns = oldState.bodyScrollableColumns;\n      columnInfo.headFixedColumns = oldState.headFixedColumns;\n      columnInfo.headFixedRightColumns = oldState.headFixedRightColumns;\n      columnInfo.headScrollableColumns = oldState.headScrollableColumns;\n      columnInfo.footFixedColumns = oldState.footFixedColumns;\n      columnInfo.footFixedRightColumns = oldState.footFixedRightColumns;\n      columnInfo.footScrollableColumns = oldState.footScrollableColumns;\n    } else {\n      var bodyColumnTypes = this._splitColumnTypes(columns);\n\n      columnInfo.bodyFixedColumns = bodyColumnTypes.fixed;\n      columnInfo.bodyFixedRightColumns = bodyColumnTypes.fixedRight;\n      columnInfo.bodyScrollableColumns = bodyColumnTypes.scrollable;\n\n      var headColumnTypes = this._splitColumnTypes(this._selectColumnElement(HEADER, columns));\n\n      columnInfo.headFixedColumns = headColumnTypes.fixed;\n      columnInfo.headFixedRightColumns = headColumnTypes.fixedRight;\n      columnInfo.headScrollableColumns = headColumnTypes.scrollable;\n\n      var footColumnTypes = this._splitColumnTypes(this._selectColumnElement(FOOTER, columns));\n\n      columnInfo.footFixedColumns = footColumnTypes.fixed;\n      columnInfo.footFixedRightColumns = footColumnTypes.fixedRight;\n      columnInfo.footScrollableColumns = footColumnTypes.scrollable;\n    }\n\n    if (canReuseColumnGroupSettings) {\n      columnInfo.groupHeaderFixedColumns = oldState.groupHeaderFixedColumns;\n      columnInfo.groupHeaderFixedRightColumns = oldState.groupHeaderFixedRightColumns;\n      columnInfo.groupHeaderScrollableColumns = oldState.groupHeaderScrollableColumns;\n    } else {\n      if (columnGroups) {\n        var groupHeaderColumnTypes = this._splitColumnTypes(this._selectColumnElement(HEADER, columnGroups));\n\n        columnInfo.groupHeaderFixedColumns = groupHeaderColumnTypes.fixed;\n        columnInfo.groupHeaderFixedRightColumns = groupHeaderColumnTypes.fixedRight;\n        columnInfo.groupHeaderScrollableColumns = groupHeaderColumnTypes.scrollable;\n      }\n    }\n\n    return columnInfo;\n  },\n  _calculateState: function _calculateState(\n  /*object*/\n  props,\n  /*?object*/\n  oldState)\n  /*object*/\n  {\n    (0, _invariant2.default)(props.height !== undefined || props.maxHeight !== undefined, 'You must set either a height or a maxHeight');\n    var children = [];\n    ReactChildren.forEach(props.children, function (child, index) {\n      if (child == null) {\n        return;\n      }\n\n      (0, _invariant2.default)(child.type.__TableColumnGroup__ || child.type.__TableColumn__, 'child type should be <FixedDataTableColumn /> or ' + '<FixedDataTableColumnGroup />');\n      children.push(child);\n    });\n    var scrollState;\n    var firstRowIndex = oldState && oldState.firstRowIndex || 0;\n    var firstRowOffset = oldState && oldState.firstRowOffset || 0;\n    var scrollY = oldState ? oldState.scrollY : 0;\n    var scrollX = oldState ? oldState.scrollX : 0;\n    var lastScrollLeft = oldState ? oldState.scrollLeft : 0;\n\n    if (props.scrollLeft !== undefined && props.scrollLeft !== lastScrollLeft) {\n      scrollX = props.scrollLeft;\n    }\n\n    if (oldState && (props.rowsCount !== oldState.rowsCount || props.rowHeight !== oldState.rowHeight || props.height !== oldState.height)) {\n      // Number of rows changed, try to scroll to the row from before the change\n      var viewportHeight = (props.height === undefined ? props.maxHeight : props.height) - (props.headerHeight || 0) - (props.footerHeight || 0) - (props.groupHeaderHeight || 0);\n      var oldViewportHeight = this._scrollHelper._viewportHeight;\n      this._scrollHelper = new _FixedDataTableScrollHelper2.default(props.rowsCount, props.rowHeight, viewportHeight, props.rowHeightGetter, props.subRowHeight, props.subRowHeightGetter);\n      scrollState = this._scrollHelper.scrollToRow(firstRowIndex, firstRowOffset);\n      firstRowIndex = scrollState.index;\n      firstRowOffset = scrollState.offset;\n      scrollY = scrollState.position;\n    } else if (oldState) {\n      if (props.rowHeightGetter !== oldState.rowHeightGetter) {\n        this._scrollHelper.setRowHeightGetter(props.rowHeightGetter);\n      }\n\n      if (props.subRowHeightGetter !== oldState.subRowHeightGetter) {\n        this._scrollHelper.setSubRowHeightGetter(props.subRowHeightGetter);\n      }\n    } // Figure out if the vertical scrollbar will be visible first,\n    // because it will determine the width of the table\n\n\n    var useGroupHeader = false;\n    var groupHeaderHeight = 0;\n\n    if (children.length && children[0].type.__TableColumnGroup__) {\n      useGroupHeader = true;\n      groupHeaderHeight = props.groupHeaderHeight;\n    }\n\n    var useMaxHeight = props.height === undefined;\n    var height = Math.round(useMaxHeight ? props.maxHeight : props.height);\n    var totalHeightReserved = props.footerHeight + props.headerHeight + groupHeaderHeight + 2 * BORDER_HEIGHT;\n    var bodyHeight = height - totalHeightReserved;\n\n    var scrollContentHeight = this._scrollHelper.getContentHeight();\n\n    var totalHeightNeeded = scrollContentHeight + totalHeightReserved;\n    var maxScrollY = Math.max(0, scrollContentHeight - bodyHeight); // If vertical scrollbar is necessary, adjust the table width to give it room\n\n    var adjustedWidth = props.width;\n\n    if (maxScrollY && props.showScrollbarY) {\n      adjustedWidth = adjustedWidth - _Scrollbar2.default.SIZE - 1;\n    }\n\n    var lastScrollToRow = oldState ? oldState.scrollToRow : undefined;\n\n    if (props.scrollToRow != null && (props.scrollToRow !== lastScrollToRow || viewportHeight !== oldViewportHeight)) {\n      scrollState = this._scrollHelper.scrollRowIntoView(props.scrollToRow);\n      firstRowIndex = scrollState.index;\n      firstRowOffset = scrollState.offset;\n      scrollY = scrollState.position;\n    }\n\n    var lastScrollTop = oldState ? oldState.scrollTop : undefined;\n\n    if (props.scrollTop != null && props.scrollTop !== lastScrollTop) {\n      scrollState = this._scrollHelper.scrollTo(props.scrollTop);\n      firstRowIndex = scrollState.index;\n      firstRowOffset = scrollState.offset;\n      scrollY = scrollState.position;\n    }\n\n    var columnResizingData;\n    var continuingResizing = props.isColumnResizing === undefined && oldState && oldState.isColumnResizing;\n\n    if (props.isColumnResizing || continuingResizing) {\n      columnResizingData = oldState && oldState.columnResizingData;\n    } else {\n      columnResizingData = EMPTY_OBJECT;\n    }\n\n    var columns;\n    var columnGroups;\n\n    if (useGroupHeader) {\n      var columnGroupSettings = _FixedDataTableWidthHelper2.default.adjustColumnGroupWidths(children, adjustedWidth);\n\n      columns = columnGroupSettings.columns;\n      columnGroups = columnGroupSettings.columnGroups;\n    } else {\n      columns = _FixedDataTableWidthHelper2.default.adjustColumnWidths(children, adjustedWidth);\n    }\n\n    var columnInfo = this._populateColumnsAndColumnData(columns, columnGroups, oldState);\n\n    var lastScrollToColumn = oldState ? oldState.scrollToColumn : undefined;\n\n    if (props.scrollToColumn !== null && props.scrollToColumn !== lastScrollToColumn && columnInfo.bodyScrollableColumns.length > 0) {\n      // If selected column is a fixed column, don't scroll\n      var fixedColumnsCount = columnInfo.bodyFixedColumns.length;\n\n      if (props.scrollToColumn >= fixedColumnsCount) {\n        var totalFixedColumnsWidth = 0;\n        var i, column;\n\n        for (i = 0; i < columnInfo.bodyFixedColumns.length; ++i) {\n          column = columnInfo.bodyFixedColumns[i];\n          totalFixedColumnsWidth += column.props.width;\n        }\n\n        var j;\n\n        for (j = 0; j < columnInfo.bodyFixedRightColumns.length; ++j) {\n          column = columnInfo.bodyFixedRightColumns[j];\n          totalFixedColumnsWidth += column.props.width;\n        } // Convert column index (0 indexed) to scrollable index (0 indexed)\n        // and clamp to max scrollable index\n\n\n        var scrollableColumnIndex = Math.min(props.scrollToColumn - fixedColumnsCount, columnInfo.bodyScrollableColumns.length - 1); // Sum width for all columns before column\n\n        var previousColumnsWidth = 0;\n\n        for (i = 0; i < scrollableColumnIndex; ++i) {\n          column = columnInfo.bodyScrollableColumns[i];\n          previousColumnsWidth += column.props.width;\n        } // Get width of scrollable columns in viewport\n\n\n        var availableScrollWidth = adjustedWidth - totalFixedColumnsWidth; // Get width of specified column\n\n        var selectedColumnWidth = columnInfo.bodyScrollableColumns[scrollableColumnIndex].props.width; // Must scroll at least far enough for end of column (prevColWidth + selColWidth)\n        // to be in viewport (availableScrollWidth = viewport width)\n\n        var minAcceptableScrollPosition = previousColumnsWidth + selectedColumnWidth - availableScrollWidth; // If scrolled less than minimum amount, scroll to minimum amount\n        // so column on right of viewport\n\n        if (scrollX < minAcceptableScrollPosition) {\n          scrollX = minAcceptableScrollPosition;\n        } // If scrolled more than previous columns, at least part of column will be offscreen to left\n        // Scroll so column is flush with left edge of viewport\n\n\n        if (scrollX > previousColumnsWidth) {\n          scrollX = previousColumnsWidth;\n        }\n      }\n    }\n\n    var scrollContentWidth = _FixedDataTableWidthHelper2.default.getTotalWidth(columns);\n\n    var horizontalScrollbarVisible = scrollContentWidth > adjustedWidth && props.overflowX !== 'hidden' && props.showScrollbarX !== false;\n\n    if (horizontalScrollbarVisible) {\n      bodyHeight -= _Scrollbar2.default.SIZE;\n      totalHeightNeeded += _Scrollbar2.default.SIZE;\n      totalHeightReserved += _Scrollbar2.default.SIZE; // If the horizontal scrollbar appears, the vertical scrollbar may now be needed\n      // since the bottom row might be partially obscured by the horizontal scrollbar.\n      // We also need to make sure we don't double-dip and adjust the width twice\n\n      var notAdjusted = adjustedWidth === props.width;\n      maxScrollY = Math.max(0, scrollContentHeight - bodyHeight);\n\n      if (notAdjusted && maxScrollY && props.showScrollbarY) {\n        adjustedWidth = adjustedWidth - _Scrollbar2.default.SIZE - 1;\n      }\n    }\n\n    var maxScrollX = Math.max(0, scrollContentWidth - adjustedWidth);\n    scrollX = Math.min(scrollX, maxScrollX);\n    scrollY = Math.min(scrollY, maxScrollY);\n\n    if (!maxScrollY) {\n      // no vertical scrollbar necessary, use the totals we tracked so we\n      // can shrink-to-fit vertically\n      if (useMaxHeight) {\n        height = totalHeightNeeded;\n      }\n\n      bodyHeight = totalHeightNeeded - totalHeightReserved;\n    }\n\n    this._scrollHelper.setViewportHeight(bodyHeight); // This calculation is synonymous to Element.scrollTop\n\n\n    var scrollTop = Math.abs(firstRowOffset - this._scrollHelper.getRowPosition(firstRowIndex)); // This case can happen when the user is completely scrolled down and resizes the viewport to be taller vertically.\n    // This is because we set the viewport height after having calculated the rows\n\n    if (scrollTop !== scrollY) {\n      scrollTop = maxScrollY;\n      scrollState = this._scrollHelper.scrollTo(scrollTop);\n      firstRowIndex = scrollState.index;\n      firstRowOffset = scrollState.offset;\n      scrollY = scrollState.position;\n    }\n\n    var cellGroupWrapperHeight = props.cellGroupWrapperHeight; // The order of elements in this object metters and bringing bodyHeight,\n    // height or useGroupHeader to the top can break various features\n\n    var newState = _extends({\n      isColumnResizing: oldState && oldState.isColumnResizing\n    }, columnInfo, props, {\n      columns: columns,\n      columnGroups: columnGroups,\n      columnResizingData: columnResizingData,\n      firstRowIndex: firstRowIndex,\n      firstRowOffset: firstRowOffset,\n      horizontalScrollbarVisible: horizontalScrollbarVisible,\n      maxScrollX: maxScrollX,\n      maxScrollY: maxScrollY,\n      reservedHeight: totalHeightReserved,\n      scrollContentHeight: scrollContentHeight,\n      scrollX: scrollX,\n      scrollY: scrollY,\n      // These properties may overwrite properties defined in\n      // columnInfo and props\n      bodyHeight: bodyHeight,\n      height: height,\n      cellGroupWrapperHeight: cellGroupWrapperHeight,\n      groupHeaderHeight: groupHeaderHeight,\n      useGroupHeader: useGroupHeader\n    });\n\n    return newState;\n  },\n  _showScrollbarY: function _showScrollbarY(\n  /*object*/\n  state) {\n    return state.maxScrollY > 0 && state.overflowY !== 'hidden' && state.showScrollbarY !== false;\n  },\n  _selectColumnElement: function _selectColumnElement(\n  /*string*/\n  type,\n  /*array*/\n  columns)\n  /*array*/\n  {\n    var newColumns = [];\n\n    for (var i = 0; i < columns.length; ++i) {\n      var column = columns[i];\n      newColumns.push(_react2.default.cloneElement(column, {\n        cell: type ? column.props[type] : column.props[CELL]\n      }));\n    }\n\n    return newColumns;\n  },\n  _splitColumnTypes: function _splitColumnTypes(\n  /*array*/\n  columns)\n  /*object*/\n  {\n    var fixedColumns = [];\n    var fixedRightColumns = [];\n    var scrollableColumns = [];\n\n    for (var i = 0; i < columns.length; ++i) {\n      if (columns[i].props.fixed) {\n        fixedColumns.push(columns[i]);\n      } else if (columns[i].props.fixedRight) {\n        fixedRightColumns.push(columns[i]);\n      } else {\n        scrollableColumns.push(columns[i]);\n      }\n    }\n\n    return {\n      fixed: fixedColumns,\n      fixedRight: fixedRightColumns,\n      scrollable: scrollableColumns\n    };\n  },\n  _onScroll: function _onScroll(\n  /*number*/\n  deltaX,\n  /*number*/\n  deltaY) {\n    if (!this._isScrolling) {\n      this._didScrollStart();\n    }\n\n    var newState = {};\n    var x = this.state.scrollX;\n\n    if (Math.abs(deltaY) > Math.abs(deltaX) && this.props.overflowY !== 'hidden') {\n      var scrollState = this._scrollHelper.scrollBy(Math.round(deltaY));\n\n      var onVerticalScroll = this.props.onVerticalScroll;\n\n      if (onVerticalScroll ? onVerticalScroll(scrollState.position) : true) {\n        var maxScrollY = Math.max(0, scrollState.contentHeight - this.state.bodyHeight);\n        newState = {\n          firstRowIndex: scrollState.index,\n          firstRowOffset: scrollState.offset,\n          scrollY: scrollState.position,\n          scrollContentHeight: scrollState.contentHeight,\n          maxScrollY: maxScrollY\n        };\n      }\n    } else if (deltaX && this.props.overflowX !== 'hidden') {\n      x += deltaX;\n      x = x < 0 ? 0 : x;\n      x = x > this.state.maxScrollX ? this.state.maxScrollX : x;\n      var roundedX = Math.round(x); //NOTE (asif) This is a hacky workaround to prevent FDT from setting its internal state\n\n      var onHorizontalScroll = this.props.onHorizontalScroll;\n\n      if (onHorizontalScroll ? onHorizontalScroll(roundedX) : true) {\n        newState = {\n          scrollX: roundedX\n        };\n      }\n    }\n\n    this.setState(newState, this._didScrollStop);\n  },\n  _onHorizontalScroll: function _onHorizontalScroll(\n  /*number*/\n  scrollPos) {\n    if (scrollPos === this.state.scrollX) {\n      return;\n    }\n\n    if (!this._isScrolling) {\n      this._didScrollStart();\n    }\n\n    var newState = {};\n    var roundedScrollPos = Math.round(scrollPos);\n    var onHorizontalScroll = this.props.onHorizontalScroll;\n\n    if (onHorizontalScroll ? onHorizontalScroll(roundedScrollPos) : true) {\n      newState = {\n        scrollX: roundedScrollPos\n      };\n    }\n\n    this.setState(newState, this._didScrollStop);\n  },\n  _onVerticalScroll: function _onVerticalScroll(\n  /*number*/\n  scrollPos) {\n    if (scrollPos === this.state.scrollY) {\n      return;\n    }\n\n    if (!this._isScrolling) {\n      this._didScrollStart();\n    }\n\n    var newState = {};\n\n    var scrollState = this._scrollHelper.scrollTo(Math.round(scrollPos));\n\n    var onVerticalScroll = this.props.onVerticalScroll;\n\n    if (onVerticalScroll ? onVerticalScroll(scrollState.position) : true) {\n      newState = {\n        firstRowIndex: scrollState.index,\n        firstRowOffset: scrollState.offset,\n        scrollY: scrollState.position,\n        scrollContentHeight: scrollState.contentHeight\n      };\n    }\n\n    this.setState(newState, this._didScrollStop);\n  },\n  _didScrollStart: function _didScrollStart() {\n    if (this._isScrolling) {\n      return;\n    }\n\n    this._isScrolling = true;\n\n    if (this.props.onScrollStart) {\n      this.props.onScrollStart(this.state.scrollX, this.state.scrollY, this.state.firstRowIndex);\n    }\n  },\n  // We need two versions of this function, one to finish up synchronously (for\n  // example, in componentWillUnmount), and a debounced version for normal\n  // scroll handling.\n  _didScrollStopSync: function _didScrollStopSync() {\n    if (!this._isScrolling) {\n      return;\n    }\n\n    this._isScrolling = false;\n    this.setState({\n      redraw: true\n    });\n\n    if (this.props.onScrollEnd) {\n      this.props.onScrollEnd(this.state.scrollX, this.state.scrollY, this.state.firstRowIndex);\n    }\n  }\n});\nvar HorizontalScrollbar = (0, _createReactClass2.default)({\n  displayName: 'HorizontalScrollbar',\n  mixins: [_ReactComponentWithPureRenderMixin2.default],\n  propTypes: {\n    contentSize: _propTypes2.default.number.isRequired,\n    offset: _propTypes2.default.number.isRequired,\n    onScroll: _propTypes2.default.func.isRequired,\n    position: _propTypes2.default.number.isRequired,\n    size: _propTypes2.default.number.isRequired\n  },\n  componentWillMount: function componentWillMount() {\n    this._initialRender = true;\n  },\n  componentDidMount: function componentDidMount() {\n    this._initialRender = false;\n  },\n  render: function render()\n  /*object*/\n  {\n    var outerContainerStyle = {\n      height: _Scrollbar2.default.SIZE,\n      width: this.props.size\n    };\n    var innerContainerStyle = {\n      height: _Scrollbar2.default.SIZE,\n      position: 'absolute',\n      overflow: 'hidden',\n      width: this.props.size\n    };\n    (0, _FixedDataTableTranslateDOMPosition2.default)(innerContainerStyle, 0, this.props.offset, this._initialRender);\n    return _react2.default.createElement('div', {\n      className: (0, _joinClasses2.default)((0, _cx2.default)('fixedDataTableLayout/horizontalScrollbar'), (0, _cx2.default)('public/fixedDataTable/horizontalScrollbar')),\n      style: outerContainerStyle\n    }, _react2.default.createElement('div', {\n      style: innerContainerStyle\n    }, _react2.default.createElement(_Scrollbar2.default, _extends({}, this.props, {\n      isOpaque: true,\n      orientation: 'horizontal',\n      offset: undefined\n    }))));\n  }\n});\nmodule.exports = FixedDataTable;","map":null,"metadata":{},"sourceType":"script"}