{"ast":null,"code":"/**\n * Copyright Schrodinger, LLC\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FixedDataTableScrollHelper\n * @typechecks\n */\n'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _PrefixIntervalTree = require('./PrefixIntervalTree');\n\nvar _PrefixIntervalTree2 = _interopRequireDefault(_PrefixIntervalTree);\n\nvar _clamp = require('./clamp');\n\nvar _clamp2 = _interopRequireDefault(_clamp);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar BUFFER_ROWS = 5;\nvar NO_ROWS_SCROLL_RESULT = {\n  index: 0,\n  offset: 0,\n  position: 0,\n  contentHeight: 0\n};\n\nvar FixedDataTableScrollHelper = function () {\n  function FixedDataTableScrollHelper(\n  /*number*/\n  rowCount,\n  /*number*/\n  defaultRowHeight,\n  /*number*/\n  viewportHeight,\n  /*?function*/\n  rowHeightGetter) {\n    var _this = this;\n\n    var defaultSubRowHeight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var\n    /*?function*/\n    subRowHeightGetter = arguments[5];\n\n    _classCallCheck(this, FixedDataTableScrollHelper);\n\n    var defaultFullRowHeight = defaultRowHeight + defaultSubRowHeight;\n    this._rowOffsets = _PrefixIntervalTree2.default.uniform(rowCount, defaultFullRowHeight);\n    this._storedHeights = new Array(rowCount);\n\n    for (var i = 0; i < rowCount; ++i) {\n      this._storedHeights[i] = defaultFullRowHeight;\n    }\n\n    this._rowCount = rowCount;\n    this._position = 0;\n    this._contentHeight = rowCount * defaultFullRowHeight;\n    this._rowHeightGetter = rowHeightGetter;\n    this._subRowHeightGetter = subRowHeightGetter;\n\n    this._fullRowHeightGetter = function (rowIdx) {\n      var rowHeight = _this._rowHeightGetter ? _this._rowHeightGetter(rowIdx) : defaultRowHeight;\n      var subRowHeight = _this._subRowHeightGetter ? _this._subRowHeightGetter(rowIdx) : defaultSubRowHeight;\n      return rowHeight + subRowHeight;\n    };\n\n    this._viewportHeight = viewportHeight;\n    this.scrollRowIntoView = this.scrollRowIntoView.bind(this);\n    this.setViewportHeight = this.setViewportHeight.bind(this);\n    this.scrollBy = this.scrollBy.bind(this);\n    this.scrollTo = this.scrollTo.bind(this);\n    this.scrollToRow = this.scrollToRow.bind(this);\n    this.setRowHeightGetter = this.setRowHeightGetter.bind(this);\n    this.setSubRowHeightGetter = this.setSubRowHeightGetter.bind(this);\n    this.getContentHeight = this.getContentHeight.bind(this);\n    this.getRowPosition = this.getRowPosition.bind(this);\n\n    this._updateHeightsInViewport(0, 0);\n  }\n\n  _createClass(FixedDataTableScrollHelper, [{\n    key: 'setRowHeightGetter',\n    value: function setRowHeightGetter(\n    /*function*/\n    rowHeightGetter) {\n      this._rowHeightGetter = rowHeightGetter;\n    }\n  }, {\n    key: 'setSubRowHeightGetter',\n    value: function setSubRowHeightGetter(\n    /*function*/\n    subRowHeightGetter) {\n      this._subRowHeightGetter = subRowHeightGetter;\n    }\n  }, {\n    key: 'setViewportHeight',\n    value: function setViewportHeight(\n    /*number*/\n    viewportHeight) {\n      this._viewportHeight = viewportHeight;\n    }\n  }, {\n    key: 'getContentHeight',\n    value: function getContentHeight()\n    /*number*/\n    {\n      return this._contentHeight;\n    }\n  }, {\n    key: '_updateHeightsInViewport',\n    value: function _updateHeightsInViewport(\n    /*number*/\n    firstRowIndex,\n    /*number*/\n    firstRowOffset) {\n      var top = firstRowOffset;\n      var index = firstRowIndex;\n\n      while (top <= this._viewportHeight && index < this._rowCount) {\n        this._updateRowHeight(index);\n\n        top += this._storedHeights[index];\n        index++;\n      }\n    }\n  }, {\n    key: '_updateHeightsAboveViewport',\n    value: function _updateHeightsAboveViewport(\n    /*number*/\n    firstRowIndex) {\n      var index = firstRowIndex - 1;\n\n      while (index >= 0 && index >= firstRowIndex - BUFFER_ROWS) {\n        var delta = this._updateRowHeight(index);\n\n        this._position += delta;\n        index--;\n      }\n    }\n  }, {\n    key: '_updateRowHeight',\n    value: function _updateRowHeight(\n    /*number*/\n    rowIndex)\n    /*number*/\n    {\n      if (rowIndex < 0 || rowIndex >= this._rowCount) {\n        return 0;\n      }\n\n      var newHeight = this._fullRowHeightGetter(rowIndex);\n\n      if (newHeight !== this._storedHeights[rowIndex]) {\n        var change = newHeight - this._storedHeights[rowIndex];\n\n        this._rowOffsets.set(rowIndex, newHeight);\n\n        this._storedHeights[rowIndex] = newHeight;\n        this._contentHeight += change;\n        return change;\n      }\n\n      return 0;\n    }\n  }, {\n    key: 'getRowPosition',\n    value: function getRowPosition(\n    /*number*/\n    rowIndex)\n    /*number*/\n    {\n      this._updateRowHeight(rowIndex);\n\n      return this._rowOffsets.sumUntil(rowIndex);\n    }\n  }, {\n    key: 'scrollBy',\n    value: function scrollBy(\n    /*number*/\n    delta)\n    /*object*/\n    {\n      if (this._rowCount === 0) {\n        return NO_ROWS_SCROLL_RESULT;\n      }\n\n      var firstRow = this._rowOffsets.greatestLowerBound(this._position);\n\n      firstRow = (0, _clamp2.default)(firstRow, 0, Math.max(this._rowCount - 1, 0));\n\n      var firstRowPosition = this._rowOffsets.sumUntil(firstRow);\n\n      var rowIndex = firstRow;\n      var position = this._position;\n\n      var rowHeightChange = this._updateRowHeight(rowIndex);\n\n      if (firstRowPosition !== 0) {\n        position += rowHeightChange;\n      }\n\n      var visibleRowHeight = this._storedHeights[rowIndex] - (position - firstRowPosition);\n\n      if (delta >= 0) {\n        while (delta > 0 && rowIndex < this._rowCount) {\n          if (delta < visibleRowHeight) {\n            position += delta;\n            delta = 0;\n          } else {\n            delta -= visibleRowHeight;\n            position += visibleRowHeight;\n            rowIndex++;\n          }\n\n          if (rowIndex < this._rowCount) {\n            this._updateRowHeight(rowIndex);\n\n            visibleRowHeight = this._storedHeights[rowIndex];\n          }\n        }\n      } else if (delta < 0) {\n        delta = -delta;\n        var invisibleRowHeight = this._storedHeights[rowIndex] - visibleRowHeight;\n\n        while (delta > 0 && rowIndex >= 0) {\n          if (delta < invisibleRowHeight) {\n            position -= delta;\n            delta = 0;\n          } else {\n            position -= invisibleRowHeight;\n            delta -= invisibleRowHeight;\n            rowIndex--;\n          }\n\n          if (rowIndex >= 0) {\n            var change = this._updateRowHeight(rowIndex);\n\n            invisibleRowHeight = this._storedHeights[rowIndex];\n            position += change;\n          }\n        }\n      }\n\n      var maxPosition = this._contentHeight - this._viewportHeight;\n      position = (0, _clamp2.default)(position, 0, maxPosition);\n      this._position = position;\n\n      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);\n\n      firstRowIndex = (0, _clamp2.default)(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));\n      firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);\n      var firstRowOffset = firstRowPosition - position;\n\n      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);\n\n      this._updateHeightsAboveViewport(firstRowIndex);\n\n      return {\n        index: firstRowIndex,\n        offset: firstRowOffset,\n        position: this._position,\n        contentHeight: this._contentHeight\n      };\n    }\n  }, {\n    key: '_getRowAtEndPosition',\n    value: function _getRowAtEndPosition(\n    /*number*/\n    rowIndex)\n    /*number*/\n    {\n      // We need to update enough rows above the selected one to be sure that when\n      // we scroll to selected position all rows between first shown and selected\n      // one have most recent heights computed and will not resize\n      this._updateRowHeight(rowIndex);\n\n      var currentRowIndex = rowIndex;\n      var top = this._storedHeights[currentRowIndex];\n\n      while (top < this._viewportHeight && currentRowIndex >= 0) {\n        currentRowIndex--;\n\n        if (currentRowIndex >= 0) {\n          this._updateRowHeight(currentRowIndex);\n\n          top += this._storedHeights[currentRowIndex];\n        }\n      }\n\n      var position = this._rowOffsets.sumTo(rowIndex) - this._viewportHeight;\n\n      if (position < 0) {\n        position = 0;\n      }\n\n      return position;\n    }\n  }, {\n    key: 'scrollTo',\n    value: function scrollTo(\n    /*number*/\n    position)\n    /*object*/\n    {\n      if (this._rowCount === 0) {\n        return NO_ROWS_SCROLL_RESULT;\n      }\n\n      if (position <= 0) {\n        // If position less than or equal to 0 first row should be fully visible\n        // on top\n        this._position = 0;\n\n        this._updateHeightsInViewport(0, 0);\n\n        return {\n          index: 0,\n          offset: 0,\n          position: this._position,\n          contentHeight: this._contentHeight\n        };\n      } else if (position >= this._contentHeight - this._viewportHeight) {\n        // If position is equal to or greater than max scroll value, we need\n        // to make sure to have bottom border of last row visible.\n        var rowIndex = this._rowCount - 1;\n        position = this._getRowAtEndPosition(rowIndex);\n      }\n\n      this._position = position;\n\n      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);\n\n      firstRowIndex = (0, _clamp2.default)(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));\n\n      var firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);\n\n      var firstRowOffset = firstRowPosition - position;\n\n      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);\n\n      this._updateHeightsAboveViewport(firstRowIndex);\n\n      return {\n        index: firstRowIndex,\n        offset: firstRowOffset,\n        position: this._position,\n        contentHeight: this._contentHeight\n      };\n    }\n    /**\n     * Allows to scroll to selected row with specified offset. It always\n     * brings that row to top of viewport with that offset\n     */\n\n  }, {\n    key: 'scrollToRow',\n    value: function scrollToRow(\n    /*number*/\n    rowIndex,\n    /*number*/\n    offset)\n    /*object*/\n    {\n      rowIndex = (0, _clamp2.default)(rowIndex, 0, Math.max(this._rowCount - 1, 0));\n      offset = (0, _clamp2.default)(offset, -this._storedHeights[rowIndex], 0);\n\n      var firstRow = this._rowOffsets.sumUntil(rowIndex);\n\n      return this.scrollTo(firstRow - offset);\n    }\n    /**\n     * Allows to scroll to selected row by bringing it to viewport with minimal\n     * scrolling. This that if row is fully visible, scroll will not be changed.\n     * If top border of row is above top of viewport it will be scrolled to be\n     * fully visible on the top of viewport. If the bottom border of row is\n     * below end of viewport, it will be scrolled up to be fully visible on the\n     * bottom of viewport.\n     */\n\n  }, {\n    key: 'scrollRowIntoView',\n    value: function scrollRowIntoView(\n    /*number*/\n    rowIndex)\n    /*object*/\n    {\n      rowIndex = (0, _clamp2.default)(rowIndex, 0, Math.max(this._rowCount - 1, 0));\n\n      this._updateRowHeight(rowIndex);\n\n      var rowBegin = this._rowOffsets.sumUntil(rowIndex);\n\n      var rowEnd = rowBegin + this._storedHeights[rowIndex];\n\n      if (rowBegin < this._position) {\n        return this.scrollTo(rowBegin);\n      } else if (this._position + this._viewportHeight < rowEnd) {\n        var position = this._getRowAtEndPosition(rowIndex);\n\n        return this.scrollTo(position);\n      }\n\n      return this.scrollTo(this._position);\n    }\n  }]);\n\n  return FixedDataTableScrollHelper;\n}();\n\nmodule.exports = FixedDataTableScrollHelper;","map":null,"metadata":{},"sourceType":"script"}